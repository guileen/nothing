/*!
 * Nothing - middleware
 * Copyright(c) 2010 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var nothing = require('./index')
  , fs = require('fs')
  , url = require('url')
  , basename = require('path').basename
  , join = require('path').join
  , ENOENT;

// COMPAT:

try {
  ENOENT = require('constants').ENOENT;
} catch (err) {
  ENOENT = process.ENOENT;
}

/**
 * Import map.
 */

var imports = {};

/**
 * Return Connect middleware with the given `options`.
 *
 * Options:
 *
 *    `force`     Always re-compile
 *    `debug`     Output debugging information
 *    `src`       Source directory used to find .njs files
 *    `dest`      Destination directory used to output .js files
 *                when undefined defaults to `src`.
 *    `compile`   Custom compile function, accepting the arguments
 *                `(str, path)`.
 *    `compress`  Whether the output .js files should be compressed
 *
 * Examples:
 * 
 * Here we set up the custom compile function so that we may
 * set the `compress` option, or define additional functions.
 * 
 * By default the compile function simply sets the `filename`
 * and renders the CSS.
 * 
 *      function compile(str, path) {
 *        return nothing(str)
 *          .set('filename', path)
 *          .set('compress', true);
 *      }
 * 
 * Pass the middleware to Connect, grabbing .njs files from this directory
 * and saving .js files to _./public_. Also supplying our custom `compile` function.
 * 
 * Following that we have a `staticProvider` layer setup to serve the .js
 * files generated by Nothing.
 * 
 *      var server = connect.createServer(
 *          nothing.middleware({
 *              src: __dirname
 *            , dest: __dirname + '/public'
 *            , compile: compile
 *          })
 *        , connect.static(__dirname + '/public')
 *      );
 * 
 * @param {Object} options
 * @return {Function}
 * @api public
 */

module.exports = function(options){
  options = options || {};

  // Accept src/dest dir
  if ('string' == typeof options) {
    options = { src: options };
  }

  // Force compilation
  var force = options.force;

  // Debug option
  var debug = options.debug;

  // Source dir required
  var src = options.src;
  if (!src) throw new Error('nothing.middleware() requires "src" directory');

  // Default dest dir to source
  var dest = options.dest
    ? options.dest
    : src;

  // Default compile callback
  options.compile = options.compile || function(str, path){
    return nothing(str)
      .set('filename', path)
      .set('compress', options.compress);
  };

  // Middleware
  return function(req, res, next){
    if ('GET' != req.method && 'HEAD' != req.method) return next();
    var path = url.parse(req.url).pathname;
    if (/\.js$/.test(path)) {
      var jsPath = join(dest, path)
        , nothingPath = join(src, path.replace('.js', '.njs'));

      if (debug) {
        log('source', nothingPath);
        log('dest', jsPath);
      }

      // Ignore ENOENT to fall through as 404
      function error(err) {
        next(ENOENT == err.errno
          ? null
          : err);
      }

      // Force
      if (force) return compile();

      // Compile to jsPath
      function compile() {
        if (debug) log('read', nothingPath);
        fs.readFile(nothingPath, 'utf8', function(err, str){
          if (err) return error(err);
          nothing.nothing(str, {level: options.level || 2}, function(err, js){
//          var style = options.compile(str, nothingPath);
//          var paths = style.options._imports = [];
//          style.render(function(err, js){
            if (err) return next(err);
            if (debug) log('render', nothingPath);
            imports[nothingPath] = imports[nothingPath] || [];
            fs.writeFile(jsPath, js, 'utf8', function(err){
              next(err);
            });
          });
        });
      }

      // Re-compile on server restart, disregarding
      // mtimes since we need to map imports
      if (!imports[nothingPath]) return compile();

      // Compare mtimes
      fs.stat(nothingPath, function(err, nothingStats){
        if (err) return error(err);
        fs.stat(jsPath, function(err, jsStats){
          // CSS has not been compiled, compile it!
          if (err) {
            if (ENOENT == err.errno) {
              if (debug) log('not found', jsPath);
              compile();
            } else {
              next(err);
            }
          } else {
            // Source has changed, compile it
            if (nothingStats.mtime > jsStats.mtime) {
              if (debug) log('modified', jsPath);
              compile();
            // Already compiled, check imports
            } else {
              checkImports(nothingPath, function(changed){
                if (debug && changed) log('modified import', changed);
                changed ? compile() : next();
              });
            }
          }
        });
      });
    } else {
      next();
    }
  }
};

/**
 * Check `path`'s imports to see if they have been altered.
 *
 * @param {String} path
 * @param {Function} fn
 * @api private
 */

function checkImports(path, fn) {
  var nodes = imports[path];
  if (!nodes) return fn();
  if (!nodes.length) return fn();

  var pending = nodes.length
    , changed = false;

  nodes.forEach(function(import){
    fs.stat(import.path, function(err, stat){
      // error
      if (err) {
        --pending || fn(changed);
      // compare mtimes
      } else if (import.mtime) {
        if (!changed) changed = stat.mtime > import.mtime
          ? import.path
          : false;
        import.mtime = stat.mtime;
        --pending || fn(changed);
      // first hit, ignore
      } else {
        import.mtime = stat.mtime;
        --pending || fn(changed);
      }
    });
  });
}

/**
 * Log a message.
 *
 * @api private
 */

function log(key, val) {
  console.error('  \033[90m%s :\033[0m \033[36m%s\033[0m', key, val);
}
